import streamlit as st
from openai import OpenAI


def main():
    st.set_page_config(layout="wide")
    st.title("문서 요약 앱")
    st.caption("스트림릿과 OpenAI API로 문서 요약하기")

    with st.sidebar:
        openai_api_key = st.text_input(
            "OpenAI API Key", key="summarizer_api_key", type="password"
        )
        st.markdown(
            "[OpenAI API key 받기](https://platform.openai.com/account/api-keys)"
        )

    system_message = """
    너는 문서 요약 전문가야. 주어진 텍스트를 간결하고 명확하게 요약해줘.
    - 요약은 항상 한글로 해야 해. 
    - 마크다운과 불렛포인트로 표현해줘
    - 요약은 원문의 핵심 내용을 포함해야 하고, 불필요한 세부사항은 제외해.
    요약 끝에는 적절한 이모티콘을 추가해줘.
    """

    if "messages" not in st.session_state:
        st.session_state.messages = [{"role": "system", "content": system_message}]

    default_user_input = """
        프롬프트 엔지니어링이란 무엇인가요?
        프롬프트 엔지니어링은 생성형 인공 지능(생성형 AI) 솔루션을 안내하여 원하는 결과를 생성하는 프로세스입니다. 생성형 AI는 인간을 모방하려고 시도하지만 고품질의 관련성 높은 결과물을 생성하려면 자세한 지침이 필요합니다. 프롬프트 엔지니어링에서는 AI가 사용자와 더 의미 있게 상호 작용하도록 안내하는 가장 적절한 형식, 구문, 단어 및 기호를 선택합니다. 프롬프트 엔지니어는 창의력을 발휘하고 시행착오를 거쳐 입력 텍스트 모음을 생성하므로 애플리케이션의 생성형 AI가 예상대로 작동합니다.

        프롬프트란 무엇인가요?
        프롬프트는 특정 작업을 수행하도록 생성형 AI에 요청하는 자연어 텍스트입니다. 생성형 AI는 스토리, 대화, 동영상, 이미지, 음악과 같은 새로운 콘텐츠를 만들어내는 인공 지능 솔루션으로, 방대한 양의 데이터로 사전 훈련된 심층 신경망을 사용하는 규모가 아주 큰 기계 학습(ML) 모델을 기반으로 합니다.

        대규모 언어 모델(LLM)은 매우 유연하며 다양한 작업을 수행할 수 있습니다. 예를 들어 문서를 요약하고, 문장을 완성하고, 질문에 답하고, 언어를 번역할 수 있습니다. 특정 사용자 입력의 경우 모델은 과거 훈련을 바탕으로 판단한 최상의 결과를 예측하는 방식으로 작동합니다.

        하지만 매우 개방적이기 때문에 사용자는 수많은 입력 데이터 조합을 통해 생성형 AI 솔루션과 상호 작용할 수 있습니다. AI 언어 모델은 매우 강력하며, 콘텐츠 제작을 시작하는 데 비용이 많이 소요되지 않습니다. 단어 하나만 제공해도 시스템에서 상세한 응답을 생성할 수 있습니다.

        그렇긴 하지만, 모든 유형의 입력이 유용한 출력을 생성하는 것은 아닙니다. 생성형 AI 시스템이 정확하고 연관성 있는 응답을 생성하기 위해서는 컨텍스트와 세부 정보가 필요합니다. 프롬프트를 체계적으로 설계하면 보다 의미 있고 유용한 결과물을 얻을 수 있습니다. 프롬프트 엔지니어링에서는 AI 시스템에서 원하는 결과를 얻을 때까지 프롬프트를 지속적으로 조정합니다.

        생성형 AI에 대해 읽어보기 »

        프롬프트 엔지니어링이 중요한 이유는 무엇인가요?
        생성형 AI가 등장한 이후 프롬프트 엔지니어링 작업이 크게 증가했습니다. 프롬프트 엔지니어는 최종 사용자와 대규모 언어 모델 간의 격차를 해소합니다. 이들은 사용자가 언어 모델에서 최상의 결과를 얻기 위해 맞춤화하고 완성할 수 있는 스크립트와 템플릿을 식별합니다. 이 엔지니어들은 다양한 유형의 입력을 실험하여 애플리케이션 개발자가 다양한 시나리오에서 재사용할 수 있는 프롬프트 라이브러리를 구축합니다.

        프롬프트 엔지니어링은 AI 애플리케이션의 효율성과 효과를 높입니다. 애플리케이션 개발자는 일반적으로 개방형 사용자 입력을 AI 모델로 전달하기 전에 프롬프트 내에 캡슐화합니다.

        AI 챗봇을 예로 들어 보겠습니다. 사용자가 ‘셔츠 구입처’와 같은 불완전한 문제 설명을 입력할 수 있습니다. 내부적으로 애플리케이션 코드는 다음과 같은 엔지니어링 프롬프트를 사용합니다. ‘당신은 의류 회사의 영업 사원입니다. 미국 앨라배마에 거주하는 한 사용자가 셔츠 구입처를 묻습니다. 현재 셔츠 재고가 있는 가장 가까운 매장 세 곳으로 응답하세요.’ 그러면 챗봇은 더 연관성이 높고 정확한 정보를 생성합니다.

        다음으로, 프롬프트 엔지니어링의 몇 가지 이점에 대해 살펴보겠습니다.

        개발자의 제어 능력 강화
        프롬프트 엔지니어링을 통해 개발자는 사용자와 AI의 상호 작용을 보다 효과적으로 제어할 수 있습니다. 효과적인 프롬프트는 대규모 언어 모델에 의도를 제시하고 컨텍스트를 설정합니다. 이를 통해 AI는 출력을 세분화하고 필요한 형식으로 간결하게 표시할 수 있습니다.

        또한 사용자가 AI를 오용하거나, AI가 알지 못하거나 정확하게 처리할 수 없는 것을 요청하지 않게 합니다. 예를 들어 사용자가 비즈니스 AI 애플리케이션에서 부적절한 콘텐츠를 생성하지 못하도록 제한할 수 있습니다.

        개선된 사용자 경험
        사용자는 시행착오를 피하면서도 AI 도구로부터 일관되고 정확하며 적절한 응답을 얻을 수 있습니다. 프롬프트 엔지니어링을 통해 사용자는 첫 번째 프롬프트에서 연관성 높은 결과를 쉽게 얻을 수 있습니다. 이는 인간의 편견으로 인해 대규모 언어 모델의 훈련 데이터에 존재할 수 있는 편견을 완화하는 데 도움이 됩니다.

        또한 사용자-AI 상호 작용을 개선하여 AI가 최소한의 입력으로도 사용자의 의도를 이해하도록 합니다. 예를 들어 법률 문서와 뉴스 기사를 요약해 달라는 요청의 경우 스타일과 어조에 따라 결과가 조정됩니다. 두 사용자가 똑같이 애플리케이션에 ‘이 문서를 요약해 주세요’라고 요청해도 결과가 조정되는 것입니다.

        유연성 향상
        추상화 수준이 높을수록 AI 모델이 개선되고, 조직이 보다 유연한 도구를 대규모로 만들 수 있습니다. 프롬프트 엔지니어는 논리적 연결과 광범위한 패턴을 강조하는 도메인 중립적 지침을 포함하는 프롬프트를 만들 수 있습니다. 조직은 기업 전반에서 프롬프트를 간단하게 재사용하여 AI 투자를 확대할 수 있습니다.

        예를 들어 프롬프트 엔지니어는 프로세스 최적화를 위한 기회를 찾기 위해 상황별 데이터 대신, 광범위한 신호를 사용하여 비효율성을 찾도록 AI 모델을 훈련하는 다양한 프롬프트를 만들 수 있습니다. 그런 다음 이 프롬프트를 다양한 프로세스와 사업부에 사용할 수 있습니다.

        (출처 : https://aws.amazon.com/ko/what-is/prompt-engineering/)
        """

    user_input = st.text_area(
        "요약할 텍스트를 입력하세요:", value=default_user_input, height=300
    )

    if st.button("텍스트 요약하기"):
        if not openai_api_key:
            st.info("계속하려면 OpenAI API 키를 추가하세요.")
            st.stop()

        if not user_input.strip():
            st.warning("요약할 텍스트를 입력해주세요.")
            st.stop()

        st.session_state["client"] = OpenAI(api_key=openai_api_key)

        prompt = f"다음 텍스트를 요약해줘:\n\n{user_input}"
        st.session_state.messages.append({"role": "user", "content": prompt})

        with st.spinner("요약 중..."):
            stream = st.session_state["client"].chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": m["role"], "content": m["content"]}
                    for m in st.session_state.messages
                ],
                stream=True,
            )
            response = st.write_stream(stream)

        st.session_state.messages.append({"role": "assistant", "content": response})


if __name__ == "__main__":
    main()
